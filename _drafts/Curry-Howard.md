---
layout: post
title: "Lambda Calculus (6 - Curry-Howard correspondence)"
categories: lambda
---

這篇文章會討論有點不同的主題
從這個問題開始：
你要怎麼寫一個term
使得他的type為\\(\forall X. X\\)？

這是一個有點有趣的型別
屬於它的term必須要能被當作任何型別的值
顯然這有點無理
假如你用的是Haskell
或者是任何一個普通的程式語言
事實上可行的辦法是讓這個函數永遠不要回傳值
舉例來說讓它進入無窮迴圈
或者是直接終止程式
不過這些基本上都是*作弊*
不是嗎？
除了作弊之外
的確你是不應該有辦法寫出這樣的term的

有沒有可能設計一個*沒辦法作弊*的程式語言呢？
有的
沒辦法作弊這樣的特性事實上有個聽起來比較專業的名詞：**一致的**
前面我們介紹的所有lambda calculus都是一致的
也就是說不存在型別為\\(\forall X. X\\)的term
一般的程式語言是在lambda calculus的基礎上加了太多其它結構
讓你有辦法作弊
為什麼那些程式語言要被這麼設計呢？
因為作弊有時的確是好的
當你寫真正的程式時
你確實可能希望進入一個無窮迴圈
永遠不要結束函數
在先前介紹的各種最精簡的typed lambda裡面
所有函數都有NF
因此我們無法辦到這點

---

我要來直接切入一致性這樣的特性有什麼特別的意義了
接下來給出的資訊可能有點多
如果還沒辦法理解的話就一次背下來再繼續讀吧

二十世紀中的數學家們發現了一件事情
*型別系統*和*邏輯*是有直接的對應的
更精確地說是如此：
不同的type可以被視為不同的**命題**
而每個type的term則是它的**證明**
這樣的關係被稱為**柯里-霍華德對應**

先來解釋一下命題是什麼
一個命題可以被看為一個邏輯中可或不可證明的合法語句
假如一個命題無論在任何前提下都成立的話
則它被稱為**套套句**
既然套套句是命題
那麼便存在（至少）一個term的type是該命題對應到的type

舉個最早被發現的對應吧
由柯里在1934年發現
這樣的對應是：型別系統裡面的\\(\to\\)(函數型別)對應到了邏輯裡面的\\(\to\\)(蘊含)
如果讀者不熟悉邏輯裡面的蘊含的話
這邊稍微介紹一下
\\(A \to B\\)在邏輯裡面的意思是**\\(A\\)蘊含\\(B\\)**
換句話說就是由\\(A\\)的真實性可以推導至\\(B\\)的真實性
單單只用\\(\to\\)
我們就能建立某些套套句
舉例來說好了
像是\\(A \to A\\)(由任何事實能推導至它本身)
或者是\\(A \to (B \to A)\\)
(如果一個命題\\(A\\)是事實
那麼任何其它命題\\(B\\)是事實都能推導出\\(A\\)是事實)
咦
有沒有覺得有種熟悉的感覺？
