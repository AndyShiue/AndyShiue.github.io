---
layout: post
title: "Lambda Calculus (6 - Curry-Howard correspondence)"
categories: lambda
---

這篇文章會討論有點不同的主題
從這個問題開始：
你要怎麼寫一個term
使得他的type為\\(\forall X. X\\)？

這是一個有點有趣的型別
屬於它的term必須要能被當作任何型別的值
顯然這有點無理
假如你用的是Haskell
或者是任何一個普通的程式語言
事實上可行的辦法是讓這個函數永遠不要回傳值
舉例來說讓它進入無窮迴圈
或者是直接終止程式
不過這些基本上都是*作弊*
不是嗎？
除了作弊之外
的確你是不應該有辦法寫出這樣的term的

有沒有可能設計一個*沒辦法作弊*的程式語言呢？
有的
沒辦法作弊這樣的特性事實上有個聽起來比較專業的名詞：**一致的**
前面我們介紹的所有lambda calculus都是一致的
也就是說不存在型別為\\(\forall X. X\\)的term
一般的程式語言是在lambda calculus的基礎上加了太多其它結構
讓你有辦法作弊
為什麼那些程式語言要被這麼設計呢？
因為作弊有時的確是好的
當你寫真正的程式時
你確實可能希望進入一個無窮迴圈
永遠不要結束函數
在先前介紹的各種最精簡的typed lambda裡面
所有函數都有NF
因此我們無法辦到這點

---
