---
layout: post
title: "Lambda Calculus (6 - Curry-Howard correspondence)"
categories: lambda
---

這篇文章會討論有點不同的主題
從這個問題開始：
你要怎麼寫一個term
使得他的type為\\(\forall X. X\\)？

這是一個有點有趣的型別
屬於它的term必須要能被當作任何型別的值
顯然這有點無理
假如你用的是Haskell
或者是任何一個普通的程式語言
事實上可行的辦法是讓這個函數永遠不要回傳值
舉例來說讓它進入無窮迴圈
或者是直接終止程式
不過這些基本上都是*作弊*
不是嗎？
除了作弊之外
的確你是不應該有辦法寫出這樣的term的

有沒有可能設計一個*沒辦法作弊*的程式語言呢？
有的
沒辦法作弊這樣的特性事實上有個聽起來比較專業的名詞：**一致的**
前面我們介紹的所有lambda calculus都是一致的
也就是說不存在型別為\\(\forall X. X\\)的term
一般的程式語言是在lambda calculus的基礎上加了太多其它結構
讓你有辦法作弊
為什麼那些程式語言要被這麼設計呢？
因為作弊有時的確是好的
當你寫真正的程式時
你確實可能希望進入一個無窮迴圈
永遠不要結束函數
在先前介紹的各種最精簡的typed lambda裡面
所有函數都有NF
因此我們無法辦到這點

---

我要來直接切入一致性這樣的特性有什麼特別的意義了
接下來給出的資訊可能有點多
如果還沒辦法理解的話就一次背下來再繼續讀吧

二十世紀中的數學家們發現了一件事情
*型別系統*和*邏輯*是有直接的對應的
更精確地說是如此：
不同的type可以被視為不同的**命題**
而每個type的term則是它的**證明**
這樣的關係被稱為**柯里-霍華德對應**

先來解釋一下命題是什麼
一個命題可以被看為一個邏輯中可或不可證明的合法語句
假如一個命題無論在任何前提下都成立的話
則它被稱為**套套句**
既然套套句是命題
那麼便存在（至少）一個term的type是該命題對應到的type

舉個最早被發現的對應吧
由柯里在1934年發現
這樣的對應是：型別系統裡面的\\(\to\\)(函數型別)對應到了邏輯裡面的\\(\to\\)(蘊含)
如果讀者不熟悉邏輯裡面的蘊含的話
這邊稍微介紹一下
\\(A \to B\\)在邏輯裡面的意思是**\\(A\\)蘊含\\(B\\)**
換句話說就是由\\(A\\)的真實性可以推導至\\(B\\)的真實性
單單只用\\(\to\\)
我們就能建立某些套套句
舉例來說好了
像是\\(A \to A\\)(由任何事實能推導至它本身)
或者是\\(A \to (B \to A)\\)
(如果一個命題\\(A\\)是事實
那麼任何其它命題\\(B\\)是事實都能推導出\\(A\\)是事實)
咦
有沒有覺得有種熟悉的感覺？

事實上
這不就是\\(\mathbf{I}\\)和\\(\mathbf{K}\\)的type嗎？
這印證了套套句能被證明這樣的說法
但\\(\mathbf{I}\\)和\\(\mathbf{K}\\)的type前面的\\(\forall\\)又要怎麼解釋呢？
根據柯里-霍華德對應
\\(\forall\\)對應到了*對於所有type......*
type被對應到了命題
所以事實上也能解釋成*對於所有命題......*
這麼一來
\\(\mathbf{I}\\)的type能被解釋成*對於所有命題\\(A\\) \\(A\\)蘊含自身*
\\(\mathbf{K}\\)的type也能被類似的方式解讀
只要在前面加上*對於所有命題\\(A\\)和\\(B\\)*就可以了
不存在type為\\(\forall X. X\\)的term也因此會是型別系統裡很重要的特色
一旦系統*不一致*
任何命題都能被證明
而顯然對於一個邏輯來說這並不是我們想要的
在CoC裡面\\(\forall\\)和\\(\to\\)已經被統一
\\(\forall A. ...)指的事實上是\\((A: Type) \to ...\\)
其實我們也能有\\((A: Bool) \to ...\\)或\\((A: Nat) \to ...\\)
分別指*對於所有布林值*和*對於所有自然數*
依此類推

現在我們不知不覺進入了一階邏輯的領域
這是型別理論和傳統邏輯不一樣的地方
在傳統邏輯中
一階邏輯的變數和命題是兩種完全不同的東西
而在型別論中
命題只不過是\\(Type\\)的元素罷了
而量詞(接收值傳回命題的函數)或高階量詞也能被輕鬆定義

命題邏輯除了\\(\to\\)之外還有很多運算子
現在我將一一定義
